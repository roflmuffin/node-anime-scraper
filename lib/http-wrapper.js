// Generated by CoffeeScript 1.10.0
var BlockedError, Bottleneck, InvalidCFCookieError, InvalidUserAgentError, KissCookie, KissHTTP, MaxRetryError, Promise, _, b, cheerio, cloudscraper, debug, got,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

got = require('got');

debug = require('debug')('test');

Promise = require('bluebird');

cloudscraper = Promise.promisifyAll(require('cloudscraper'));

_ = require('lodash');

cheerio = require('cheerio');

Bottleneck = require('bottleneck');

KissCookie = require('./cookie-storage');

b = new Bottleneck(1, 0);

InvalidUserAgentError = (function(superClass) {
  extend(InvalidUserAgentError, superClass);

  function InvalidUserAgentError() {
    this.name = 'InvalidUserAgentError';
    this.message = 'The user-agent used to request content differs from the user-agent accepted by Cloudflare.';
    Error.captureStackTrace(this, InvalidUserAgentError);
  }

  return InvalidUserAgentError;

})(Error);

InvalidCFCookieError = (function(superClass) {
  extend(InvalidCFCookieError, superClass);

  function InvalidCFCookieError() {
    this.name = 'InvalidCFCookieError';
    this.message = 'The the cloudflare cookie used to request content is no longer valid.';
    Error.captureStackTrace(this, InvalidCFCookieError);
  }

  return InvalidCFCookieError;

})(Error);

BlockedError = (function(superClass) {
  extend(BlockedError, superClass);

  function BlockedError(reason, body) {
    var $;
    $ = cheerio.load(body);
    reason = $('.barContent').text();
    this.name = 'BlockedError';
    this.message = "You have been blocked, the page states:  " + (reason.trim());
    Error.captureStackTrace(this, BlockedError);
  }

  return BlockedError;

})(Error);

MaxRetryError = (function(superClass) {
  extend(MaxRetryError, superClass);

  function MaxRetryError() {
    this.name = 'MaxRetryError';
    this.message = 'Retrieving page after 5 attempts failed. Something has most likely been broken by external forces.';
    Error.captureStackTrace(this, MaxRetryError);
  }

  return MaxRetryError;

})(Error);

KissHTTP = (function() {
  var DEFAULT_OPTIONS;

  DEFAULT_OPTIONS = {
    method: 'GET',
    headers: {
      'user-agent': 'got/6.11 (https://github.com/sindresorhus/got)'
    },
    followRedirect: true,
    save_cookies: true
  };

  function KissHTTP(options) {
    this.options = _.merge(DEFAULT_OPTIONS, options);
    if (this.options.save_cookies) {
      this.cookie_storage = new KissCookie();
      this.options.headers.cookie = this.cookie_storage.loadCookie();
    }
  }

  KissHTTP.prototype.setDelay = function(amount) {
    return b = new Bottleneck(1, amount);
  };

  KissHTTP.prototype.getFreshCookie = function() {
    debug('Retrieving fresh Cloudflare cookie.');
    return new Promise((function(_this) {
      return function(resolve, reject) {
        return cloudscraper.get('https://kissanime.ru', function(err, resp) {
          if (err) {
            return reject(new Error('Unable to bypass Cloudflare protection.'));
          } else {
            _this.options.headers.cookie = resp.request.headers.cookie;
            if (_this.options.save_cookies) {
              _this.cookie_storage.saveCookie(resp.request.headers.cookie);
            }
            debug('Fresh Cloudflare cookie retrieved.');
            return resolve();
          }
        }, {
          'User-Agent': _this.options.headers['user-agent']
        });
      };
    })(this));
  };

  KissHTTP.prototype.request = function(url, options) {
    var local_options;
    if (options == null) {
      options = {
        retries: 0
      };
    }
    local_options = _.merge(this.options, options);
    return b.schedule(got, url, local_options).then(function(resp) {
      if (resp.body.indexOf('Are you human?') > -1) {
        throw new BlockedError('Captcha Blocked', resp.body);
      } else if (resp.body.indexOf('does not allow unofficial apps') > -1) {
        throw new BlockedError('Blocked IP', resp.body);
      } else {
        return resp;
      }
    })["catch"](function(err) {
      debug(err);
      if (err instanceof BlockedError) {
        throw err;
      } else if (err.name === 'HTTPError') {
        debug("Received HTTP error retrieving URL: " + url);
        throw err;
      } else if (local_options.retries > 5) {
        throw new MaxRetryError();
      }
      if (err.name === 'InvalidCFCookieError') {
        throw new InvalidCFCookieError();
      } else {
        throw err;
      }
    })["catch"]((function(_this) {
      return function(err) {
        local_options.retries += 1;
        if (err.name === 'MaxRetryError' || err.name === 'BlockedError') {
          throw err;
        } else {
          return _this.getFreshCookie().then(function() {
            return _this.request(url, local_options);
          });
        }
      };
    })(this));
  };

  return KissHTTP;

})();

module.exports = KissHTTP;
